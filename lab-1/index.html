<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Лабораторная работа #1 - Web-программирвоание</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 #1";
        var mkdocs_page_input_path = "lab-1.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Web-программирвоание
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Главная</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Лабораторная работа #1</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#1_1">Задание #1</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_1">Описание</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_2">Решение</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#2">Задание #2</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">Описание</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">Решение</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#3">Задание #3</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_5">Описание</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">Решение</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#4">Задание #4</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_7">Описание</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">Решение</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#5">Задание #5</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_9">Описание</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_10">Решение</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../lab-2/">Лабораторная работа #2</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../lab-3/">Лабораторная работа #3</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../lab-4/">Лабораторная работа #4</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../pract-3-1/">Практическая работа #3.1</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Web-программирвоание</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Лабораторная работа #1</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="1">Лабораторная работа #1</h1>
<h2 id="1_1">Задание #1</h2>
<h3 id="_1">Описание</h3>
<p>Реализовать клиентскую и серверную часть приложения. Клиент отсылает серверу
сообщение «Hello, server». Сообщение должно отразиться на стороне сервера.
Сервер в ответ отсылает клиенту сообщение «Hello, client». Сообщение должно
отобразиться у клиента.</p>
<ul>
<li>Обязательно использовать библиотеку <code>socket</code></li>
<li>Реализовать с помощью протокола UDP</li>
</ul>
<h3 id="_2">Решение</h3>
<p><strong>Сервер</strong></p>
<p>Импортируем библиотеку <code>socket</code>. Создаем объект socket и связываем его с нашим хостом и с портом 3001.</p>
<pre><code class="language-python">import socket

# creating socket obj, where
# AF_INET - IPv4 family
# SOCK_DGRAM - UDP
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

s.bind(('', 3001))
</code></pre>
<p>Получаем данные с максимальным размером 1024 байта и ip-адрес клиента. Затем выводим декодированные данные с utf-8 кодировкой.</p>
<pre><code class="language-python"># receive data (1024 bytes) and ip address from a client
data, client_addr = s.recvfrom(1024)
print(data.decode())
</code></pre>
<p>Отправляем клиенту ответ: "Hello, Client!".</p>
<pre><code class="language-python"># send a response to the client
s.sendto(b&quot;Hello, Client!&quot;, client_addr)
</code></pre>
<p><strong>Клиент</strong></p>
<p>Импортируем библиотеку <code>socket</code> и создаем объект socket.</p>
<pre><code class="language-python">import socket

# creating socket obj, where
# AF_INET - IPv4 family
# SOCK_DGRAM - UDP
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
</code></pre>
<p>Отправляем данные на сервер с известным нам портом 3001.</p>
<pre><code class="language-python"># send bytes to the server address
s.sendto(b&quot;Hello, Server!&quot;, ('', 3001))
</code></pre>
<p>Ждем ответ от сервера и выводим его.</p>
<pre><code class="language-python"># wait for server reply
data = s.recv(1024)
print(data.decode())
</code></pre>
<hr />
<h2 id="2">Задание #2</h2>
<h3 id="_3">Описание</h3>
<p>Реализовать клиентскую и серверную часть приложения. Клиент запрашивает у
сервера выполнение математической операции, параметры, которые вводятся с
клавиатуры. Сервер обрабатывает полученные данные и возвращает результат
клиенту.</p>
<p>Вариант: <strong>Теорема Пифагора</strong></p>
<ul>
<li>Обязательно использовать библиотеку <code>socket</code></li>
<li>Реализовать с помощью протокола TCP</li>
</ul>
<h3 id="_4">Решение</h3>
<p><strong>Сервер</strong></p>
<p>Создаем сокет с протоколом TCP и привязываем его к данному хосту с портом 3001. С помощью метода <code>listen</code> запускаем режим прослушивания для данного сокета с максимальным количеством подключений равному 1.</p>
<pre><code class="language-python">import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 3001))
s.listen(1)
</code></pre>
<p>Ожидаем поключение к серверу. После того, как клиент подключится, сервер отправит сообщение-подсказку.</p>
<pre><code class="language-python">conn, addr = s.accept()
conn.send(b&quot;Enter a b sides of right triangle:&quot;)
</code></pre>
<p>Одидаем ответ от клиента, обрабатываем его полученные данные и отправляем ответ с результатом вычисленной гипотенузы.</p>
<pre><code class="language-python">data = conn.recv(1024)
a, b = list(map(int, data.decode().split()))
hypotenuse = (a**2 + b**2) ** 0.5

conn.sendall(str(hypotenuse).encode())
conn.close()
</code></pre>
<p><strong>Клиент</strong></p>
<p>Подключаемся к TCP серверу. </p>
<pre><code class="language-python">import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('', 3001))
</code></pre>
<p>Получаем сообщение-подсказку. </p>
<pre><code class="language-python">msg = s.recv(1024).decode()
print(msg)
</code></pre>
<p>Запрашиваем у пользователя данные и отправляем их на сервер. После чего выводим ответ от сервера.</p>
<pre><code class="language-python">data = input().encode()
s.send(data)
print(s.recv(1024).decode())
</code></pre>
<hr />
<h2 id="3">Задание #3</h2>
<h3 id="_5">Описание</h3>
<p>Реализовать серверную часть приложения. Клиент подключается к серверу. В ответ
клиент получает http-сообщение, содержащее html-страницу, которую сервер
подгружает из файла index.html.</p>
<ul>
<li>Обязательно использовать библиотеку <code>socket</code></li>
</ul>
<h3 id="_6">Решение</h3>
<p><strong>Сервер</strong></p>
<p>Создаем TCP сокет с привязкой к данному хосту. Когда приходит соединение, отправляем http ответ клиенту.</p>
<pre><code class="language-python">import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 3001))
s.listen(1)

conn, addr = s.accept()
http_data = create_http_response(open(&quot;./index.html&quot;).read())
conn.sendall(http_data)
conn.close()
</code></pre>
<p>Функция, формирующая http ответ.</p>
<pre><code class="language-python">def create_http_response(body: str) -&gt; bytes:
  header = f&quot;HTTP/1.2 200 OK\nContent-Type: text/html; charset=utf-8\nContent-Length: {len(body)}&quot;
  request = f&quot;{header}\n\n{body}&quot;
  return request.encode()
</code></pre>
<p><strong>Клиент</strong></p>
<p>Соединяемся с TCP сервером и обрабатываем ответ.</p>
<pre><code class="language-python">import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('', 3001))

data = read_server_data(s)
body = read_http_body(data)

print(body)
</code></pre>
<p>Функция, читающая ответ с сервера по чанкам</p>
<pre><code class="language-python">def read_server_data(s: socket.socket, chunk_size=1024) -&gt; bytes:
  result = b&quot;&quot;
  while True:
    data = s.recv(chunk_size)
    if not data:
      break
    result += data
  return result
</code></pre>
<p>Функция, которая выводит body с http ответа сервера.</p>
<pre><code class="language-python">def read_http_body(response: bytes) -&gt; str:
  lines = response.decode().splitlines()
  body_start = next((i for i, line in enumerate(lines) if line == &quot;&quot;), -1)
  if body_start == -1:
    raise ValueError(&quot;Invalid HTTP&quot;)
  return &quot;\n&quot;.join(lines[body_start + 1:])
</code></pre>
<hr />
<h2 id="4">Задание #4</h2>
<h3 id="_7">Описание</h3>
<p>Реализовать двухпользовательский или многопользовательский чат. Реализация
многопользовательского чата позволяет получить максимальное количество
баллов.</p>
<ul>
<li>Реализовать с помощью протокола TCP – 100% баллов, с помощью UDP – 80%.</li>
<li>Обязательно использовать библиотеку <code>threading</code>.</li>
<li>Для реализации с помощью UDP, thearding использовать для получения
сообщений у клиента.</li>
<li>Для применения с TCP необходимо запускать клиентские подключения И прием
и отправку сообщений всем юзерам на сервере в потоках. Не забудьте сохранять юзеров,
чтобы потом отправлять им сообщения.</li>
</ul>
<h3 id="_8">Решение</h3>
<p><strong>Сервер</strong></p>
<p>Импортируем библиотеки.</p>
<pre><code class="language-python">import os
import socket
from threading import Thread
from constants import separator
</code></pre>
<p>Основная часть серверной части кода. После создания TCP сервера, объявляем переменную connections, в которой будем хранить все соединения. Для каждого пользователя открываем отдельный thread для прослушивания его сообщений. </p>
<pre><code class="language-python">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# make port reusable
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(('', 3001))
s.listen(os.cpu_count())

connections: set[socket.socket] = set()
while True:
  conn, addr = s.accept()
  print(f&quot;{addr} has connected.&quot;)
  connections.add(conn)

  # thread for listening client's messages
  t = Thread(target=listen_for_client, args=(conn,))
  t.start()
</code></pre>
<p>Функция прослушивания сообщений пользователей. После получения сообщения, каждому подключенному клиенту отправляется полученное сообщение.</p>
<pre><code class="language-python">def listen_for_client(conn):
  global connections

  while True:
    try:
      msg = conn.recv(1024).decode()
    except Exception as e:
      # client no longer connected
      print(f&quot;client no longer connected.&quot;)
      connections.remove(conn)
    else:
      msg = msg.replace(separator, &quot;: &quot;)

    # iterate over all connected sockets
    for client_socket in connections:
      client_socket.sendall(msg.encode())
</code></pre>
<p><strong>Клиент</strong></p>
<pre><code class="language-python">import socket
import random
from threading import Thread
from datetime import datetime
from colorama import Fore
from constants import separator, colors
</code></pre>
<p>В основной части подклбчаемся к TCP серверу. Определяем цвет для пользователя, чтобы в чате сообщения выделялись определенным цветом. Запрашиваем его имя. После чего, создаем thread, в котором данный клиент будет получать сообщения от сервера.</p>
<pre><code class="language-python">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('', 3001))

# choose a random color for the client
user_color = random.choice(colors)
username = input(&quot;Enter your name: &quot;)

# make a thread that listens for messages to this client &amp; print them
t = Thread(target=listen_for_messages, args=(s,))
t.start()
</code></pre>
<p>В этой функции идет вывод полученных ретранслированных сообщений от сервера. </p>
<pre><code class="language-python">def listen_for_messages(s: socket):
  try:
    while True:
      msg = s.recv(1024).decode()
      print(msg)
  finally:
    s.close()
</code></pre>
<p>Данный код обрабатывает отправку сообщений от данного клиента.</p>
<pre><code class="language-python">while True:
  msg = input()

  if msg.lower() == '/exit':
    break

  date_now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

  s.sendall(f&quot;{user_color}[{date_now}] {username}{separator}{msg}{Fore.RESET}&quot;.encode())
</code></pre>
<hr />
<h2 id="5">Задание #5</h2>
<h3 id="_9">Описание</h3>
<p>Необходимо написать простой web-сервер для обработки GET и POST http
запросов средствами Python и библиотеки socket.</p>
<p>Задание - сделать сервер, который может:</p>
<ul>
<li>Принять и записать информацию о дисциплине и оценке по дисциплине.</li>
<li>Отдать информацию обо всех оценах по дсициплине в виде html-страницы.</li>
</ul>
<h3 id="_10">Решение</h3>
<p>Определяем дата-классы, которые представляют из себя http-запрос и http-ответ. Для хранения оценок о предмете будем использовать defaultdict из библиотеки <code>collections</code>.</p>
<pre><code class="language-python">import socket
import json
from collections import defaultdict
from dataclasses import dataclass
from http import HTTPStatus
from urllib.parse import urlparse, parse_qs

DB = defaultdict(list)


@dataclass
class HTTPRequest:
  method: str
  url: str
  protocol: str
  headers: dict[str, str]
  body: bytes


@dataclass
class HTTPResponse:
  status: int
  headers: dict[str, str]
  body: bytes
  protocol: str = &quot;HTTP/1.2&quot;

  def __bytes__(self):
    headers_str = &quot;\n&quot;.join(f&quot;{key}: {val}&quot; for key, val in self.headers.items())
    return f&quot;{self.protocol} {self.status} {HTTPStatus(self.status).phrase}\n{headers_str}\n\n&quot;.encode() + self.body
</code></pre>
<p>Определяем конструктор класса, в котором также инициализируем сокет с протоколом TCP. Для того, чтобы запустить данный сервер используется функция <code>serve_forever</code>, в которой уже биндится хост и порт. Все соединения которые сервер принимает обрабатывает функция <code>serve_client</code>.</p>
<pre><code class="language-python">class MyHTTPServer:

  def __init__(self, host: str, port: int) -&gt; None:
    self.host = host
    self.port = port
    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

  def serve_forever(self):
    self.socket.bind((self.host, self.port))
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    self.socket.listen()
    while True:
      conn, addr = self.socket.accept()
      self.serve_client(conn)

  def serve_client(self, conn: socket.socket):
    req = self.parse_request(conn)
    resp = self.handle_request(req)
    self.send_response(conn, resp)

    if conn:
      conn.close()
</code></pre>
<p>В <code>parse_request</code> мы просто обрабатываем данные и приводим в нужный нам вид <code>HTTPRequest</code>.</p>
<pre><code class="language-python">def parse_request(self, conn: socket.socket) -&gt; HTTPRequest:
  lines = conn.recv(1024*10).splitlines()

  # parse first line
  try:
    method, url, protocol = lines[0].decode().strip().split()
  except IndexError:
    raise Exception(&quot;First line is incorrect&quot;)

  headers, body_start_index = self.parse_headers(lines)
  body = b&quot;&quot;.join(lines[body_start_index + 2:])

  return HTTPRequest(method, url, protocol, headers, body)
</code></pre>
<p><code>parse_headers</code> обрабатывает заголовки.</p>
<pre><code class="language-python">def parse_headers(self, lines) -&gt; dict[str, str]:
  headers: dict[str, str] = {}
  index = 1
  req_generator = ( (n, i.decode()) for n, i in enumerate(lines[1:], 1) )
  while (data := next(req_generator, None)) is not None and data[1].strip() != &quot;&quot;:
    index, header = data
    try:
      key, val = header.split(&quot;:&quot;, 1)
      headers[key.lower()] = val.strip()
    except ValueError:
      raise Exception(&quot;Headers are incorrect&quot;)
  return headers, index
</code></pre>
<p>Данный метод обрабатывает запрос. В нем содержится вся бизнес-логика данного сервера. В качестве возвращаемых данных - собранный <code>HTTPResponse</code>.</p>
<pre><code class="language-python">def handle_request(self, req: HTTPRequest) -&gt; HTTPResponse:
  parsed_url = urlparse(req.url)
  query = parse_qs(parsed_url.query)

  print(req)

  if req.method == &quot;GET&quot; and parsed_url.path == &quot;/scores&quot;:
    if &quot;subject&quot; not in query:
      return HTTPResponse(
        status=400,
        headers={&quot;Content-Type&quot;: &quot;application/json&quot;},
        body=json.dumps({&quot;desc&quot;: &quot;you need to specify subject param&quot;}).encode()
      )

    return HTTPResponse(
      status=200,
      headers={&quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;},
      body=f&quot;&quot;&quot;
      &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;
        &lt;table&gt;
          &lt;tr&gt;&lt;th&gt;{query['subject'][0]}&lt;/th&gt;&lt;/tr&gt;
          &lt;tr&gt;
            &lt;td&gt;{&quot;&lt;/td&gt;&lt;td&gt;&quot;.join(DB[query['subject'][0]])}&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
      &lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;.encode()
    )
  elif req.method == &quot;POST&quot; and parsed_url.path == &quot;/subject&quot;:
    if &quot;name&quot; not in query:
      return HTTPResponse(
        status=400,
        headers={&quot;Content-Type&quot;: &quot;application/json&quot;},
        body=json.dumps({&quot;desc&quot;: &quot;you need to specify name param&quot;}).encode()
      )
    if &quot;score&quot; not in query:
      return HTTPResponse(
        status=400,
        headers={&quot;Content-Type&quot;: &quot;application/json&quot;},
        body=json.dumps({&quot;desc&quot;: &quot;you need to specify score param&quot;}).encode()
      )
    DB[query[&quot;name&quot;][0]].append(query[&quot;score&quot;][0])
    return HTTPResponse(status=200, headers={}, body=b&quot;&quot;)
  return HTTPResponse(status=400, headers={}, body=b&quot;&quot;)
</code></pre>
<p>Так присходит запуск сервера.</p>
<pre><code class="language-python">server = MyHTTPServer(&quot;localhost&quot;, 3004)
try:
  server.serve_forever()
except KeyboardInterrupt:
  pass
</code></pre>
<p>Посмотреть оценки по дисциплину.</p>
<pre><code>GET /scores?subject=test
</code></pre>
<p>Внести оценки по дисциплину.</p>
<pre><code>POST /subject?name=test&amp;score=10
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href=".." class="btn btn-neutral float-left" title="Главная"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../lab-2/" class="btn btn-neutral float-right" title="Лабораторная работа #2">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href=".." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../lab-2/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
